
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>html2ans.base &#8212; html2ans 3.0.4 documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for html2ans.base</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">bs4</span> <span class="k">import</span> <span class="n">BeautifulSoup</span><span class="p">,</span> <span class="n">NavigableString</span><span class="p">,</span> <span class="n">Tag</span>
<span class="kn">from</span> <span class="nn">html2ans.parsers.base</span> <span class="k">import</span> <span class="n">AbstractParserUtilities</span><span class="p">,</span> <span class="n">ParseResult</span>
<span class="kn">from</span> <span class="nn">html2ans.exc</span> <span class="k">import</span> <span class="n">ParsingException</span>


<div class="viewcode-block" id="AbstractHtmlAnsParser"><a class="viewcode-back" href="../../base.html#html2ans.base.AbstractHtmlAnsParser">[docs]</a><span class="k">class</span> <span class="nc">AbstractHtmlAnsParser</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The abstract base root/top-level parser class. Makes no assumptions about</span>
<span class="sd">    underlying libraries.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="AbstractHtmlAnsParser.generate_ans"><a class="viewcode-back" href="../../base.html#html2ans.base.AbstractHtmlAnsParser.generate_ans">[docs]</a>    <span class="k">def</span> <span class="nf">generate_ans</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">html</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parses html and produces ANS in a jsonify-able format.</span>

<span class="sd">        :param html: the html to parse</span>
<span class="sd">        :type html: str</span>
<span class="sd">        :return: a list of ANS elements as dictionaries</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="BaseHtmlAnsParser"><a class="viewcode-back" href="../../base.html#html2ans.base.BaseHtmlAnsParser">[docs]</a><span class="k">class</span> <span class="nc">BaseHtmlAnsParser</span><span class="p">(</span><span class="n">AbstractHtmlAnsParser</span><span class="p">,</span> <span class="n">AbstractParserUtilities</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The base root/top-level parser class; assumes elements will be parsed with ``BeautifulSoup``.</span>
<span class="sd">    Use this class to generate a list of ANS elements from an HTML document.</span>
<span class="sd">    HTML elements within the document will be parsed using</span>
<span class="sd">    element parsers present in the ``parsers`` attribute. The ``parsers`` attribute is populated</span>
<span class="sd">    first with the parsers from the ``DEFAULT_PARSERS`` variable. Other parsers can be added</span>
<span class="sd">    using this class&#39;s ``add_parser`` and ``insert_parser`` methods.</span>

<span class="sd">    Attempts at parsing an element will use each parser in an element&#39;s parser list in order.</span>
<span class="sd">    If a parser isn&#39;t applicable (``is_applicable`` returns ``False``) or ``parse`` indicates</span>
<span class="sd">    this element wasn&#39;t a match, the next parser is tried. Why are there two ways of indicating</span>
<span class="sd">    if an element/parser are compatable? You can&#39;t always tell if an element/parser are compatible</span>
<span class="sd">    until you&#39;re parsing the element. ``is_applicable`` catches early, obvious issues (like &quot;this</span>
<span class="sd">    parser is for ``img`` elements; is this an ``img``?).</span>

<span class="sd">    Using an ``ans_version`` won&#39;t affect the output of these parsers in terms of actual</span>
<span class="sd">    ANS version compatibility; it is provided as a convenience (sometimes you need to update</span>
<span class="sd">    the overall ANS version because of a specific new feature, but won&#39;t want to update the</span>
<span class="sd">    output of all parsers).</span>

<span class="sd">    Use the ``suppress_exceptions`` option to treat element parsing exceptions as non-matches.</span>
<span class="sd">    With ``suppress_exceptions``, when exceptions are thrown, the next parser will be tried (as</span>
<span class="sd">    though ``is_applicable`` returned ``False``).</span>

<span class="sd">    :keyword ans_version: the ANS version to apply to the output of parsers that require a version</span>
<span class="sd">    :type ans_version: str</span>
<span class="sd">    :keyword bs_parse_lib: the BeautifulSoup parsing library to use</span>
<span class="sd">    :type bs_parse_lib: str</span>
<span class="sd">    :keyword suppress_exceptions: whether or not to suppress exceptions during element parsing</span>
<span class="sd">    :type suppress_exceptions: bool</span>
<span class="sd">    :keyword default_parsers: The default parsers to populate ``parsers`` with. Order matters here!</span>
<span class="sd">    :type default_parsers: list</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">BACKUP_PARSERS</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The backup parsers for this class to use. This list will be used on _every_ parsing</span>
<span class="sd">    attempt if the primary parsers for a given type don&#39;t match. For example, if ``parsers``</span>
<span class="sd">    contains ``&#39;p&#39;: [ParagraphParser()]`` and an exception is thrown when processing a</span>
<span class="sd">    paragraph tag using the ``ParagraphParser``, all backup parsers will also be tried. In</span>
<span class="sd">    the default implementation, this essentially means that producing raw_html will be</span>
<span class="sd">    the last resort when all other parsers fail.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">ans_version</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">soup_parse_lib</span><span class="o">=</span><span class="s1">&#39;lxml&#39;</span><span class="p">,</span>
            <span class="n">suppress_exceptions</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">default_parsers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ans_version</span> <span class="o">=</span> <span class="n">ans_version</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">soup_parse_lib</span> <span class="o">=</span> <span class="n">soup_parse_lib</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">suppress_exceptions</span> <span class="o">=</span> <span class="n">suppress_exceptions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parsers</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A mapping of potential HTML elements to a list of</span>
<span class="sd">        parsers to use to attempt to parse elements of that type</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">default_parsers</span> <span class="o">=</span> <span class="n">default_parsers</span> <span class="ow">or</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">parser</span> <span class="ow">in</span> <span class="n">default_parsers</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_parser</span><span class="p">(</span><span class="n">parser</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">BaseHtmlAnsParser</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

<div class="viewcode-block" id="BaseHtmlAnsParser.generate_ans"><a class="viewcode-back" href="../../base.html#html2ans.base.BaseHtmlAnsParser.generate_ans">[docs]</a>    <span class="k">def</span> <span class="nf">generate_ans</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">html</span><span class="p">,</span> <span class="n">start_tag</span><span class="o">=</span><span class="s2">&quot;body&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parses html and produces ANS in a jsonify-able format.</span>

<span class="sd">        :param html: the html to parse</span>
<span class="sd">        :type html: str</span>
<span class="sd">        :param start_tag: where to start parsing (if not provided, all tags will be parsed)</span>
<span class="sd">        :type start_tag: str</span>
<span class="sd">        :return: a list of ANS elements as dictionaries</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">html</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">soup_parse_lib</span><span class="p">)</span>
        <span class="n">main_tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">start_tag</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">main_tag</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_elements</span><span class="p">(</span><span class="n">main_tag</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_elements</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="kc">True</span><span class="p">))</span></div>

<div class="viewcode-block" id="BaseHtmlAnsParser.insert_parser"><a class="viewcode-back" href="../../base.html#html2ans.base.BaseHtmlAnsParser.insert_parser">[docs]</a>    <span class="k">def</span> <span class="nf">insert_parser</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element_key</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Insert a parser of the given type into the list of parsers for that type.</span>

<span class="sd">        :param element_key: The key of the element in self.parsers (e.g. &#39;p&#39;)</span>
<span class="sd">        :type element_key: str</span>
<span class="sd">        :param parser: The parser object to insert</span>
<span class="sd">        :type parser: html2ans.parsers.base.ElementParser</span>
<span class="sd">        :param position: Where to insert the parser in the list</span>
<span class="sd">        :type position: int</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">applicable_parsers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parsers</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">element_key</span><span class="p">,</span> <span class="p">[])</span>
        <span class="k">if</span> <span class="n">position</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">applicable_parsers</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">parser</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">applicable_parsers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">parser</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parsers</span><span class="p">[</span><span class="n">element_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">applicable_parsers</span></div>

<div class="viewcode-block" id="BaseHtmlAnsParser.add_parser"><a class="viewcode-back" href="../../base.html#html2ans.base.BaseHtmlAnsParser.add_parser">[docs]</a>    <span class="k">def</span> <span class="nf">add_parser</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a parser to ``self.parsers`` using the parser&#39;s ``applicable_elements``.</span>

<span class="sd">        :param parser: The parser object to insert</span>
<span class="sd">        :type parser: html2ans.parsers.base.BaseElementParser</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">element_key</span> <span class="ow">in</span> <span class="n">parser</span><span class="o">.</span><span class="n">applicable_elements</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">insert_parser</span><span class="p">(</span><span class="n">element_key</span><span class="p">,</span> <span class="n">parser</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_parse_elements</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elements</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parses a list of html elements (produced by ``BeautifulSoup``) to ANS.</span>

<span class="sd">        :param elements: the list of children to parse</span>
<span class="sd">        :return: a list of ANS elements</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">output_elements</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">elements</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_empty</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_wrapper</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">Tag</span><span class="p">):</span>
                    <span class="n">output_elements</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parse_elements</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">children</span><span class="p">))</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">Tag</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_parse_element</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">output_elements</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_parse_element</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">item</span><span class="p">),</span> <span class="n">item</span><span class="p">,</span> <span class="n">output_elements</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output_elements</span>

    <span class="k">def</span> <span class="nf">_parse_element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element_key</span><span class="p">,</span> <span class="n">element</span><span class="p">,</span> <span class="n">output_elements</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Builds a list of parsers for the given element (using ``self.parsers`` and</span>
<span class="sd">        ``self.BACKUP_PARSERS``). If ``_attempt_element_parse`` returns a</span>
<span class="sd">        successful result, adds that result to the list of ``output_elements``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parser_candidates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parsers</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">element_key</span><span class="p">,</span> <span class="p">[])</span>
        <span class="c1"># if none of the parser_candidates work, we want to check for embeds or</span>
        <span class="c1"># lastly, use raw_html</span>
        <span class="c1"># the BACKUP_PARSERS handle this logic</span>
        <span class="n">parser_candidates</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">BACKUP_PARSERS</span><span class="p">)</span>
        <span class="n">parser_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attempt_element_parse</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">parser_candidates</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">parser_result</span><span class="o">.</span><span class="n">match</span> <span class="ow">and</span> <span class="n">parser_result</span><span class="o">.</span><span class="n">output</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parser_result</span><span class="o">.</span><span class="n">output</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="c1"># allows parsers to parser out multiple elements</span>
                <span class="n">output_elements</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">parser_result</span><span class="o">.</span><span class="n">output</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">output_elements</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">parser_result</span><span class="o">.</span><span class="n">output</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_attempt_element_parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">,</span> <span class="n">parser_candidates</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tries to parse the given ``element`` using each parser in ``parser_candidates``</span>
<span class="sd">        until one is a match. If the parser has ``version_required`` set to true, the</span>
<span class="sd">        ANS version is added to the output.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">parser</span> <span class="ow">in</span> <span class="n">parser_candidates</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">parser</span><span class="o">.</span><span class="n">is_applicable</span><span class="p">(</span><span class="n">element</span><span class="p">):</span>
                    <span class="n">parser_result</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">parser_result</span><span class="o">.</span><span class="n">match</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">parser_result</span><span class="o">.</span><span class="n">output</span> <span class="ow">and</span> <span class="n">parser</span><span class="o">.</span><span class="n">version_required</span><span class="p">:</span>
                            <span class="n">parser_result</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;version&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ans_version</span><span class="p">)</span>
                        <span class="k">return</span> <span class="n">parser_result</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">suppress_exceptions</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ParsingException</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ParseResult</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">html2ans</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev_guide.html">Development Guide</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="https://pypi.org/project/html2ans/">html2ans @ PyPi</a></li>
    
    <li class="toctree-l1"><a href="https://github.com/washingtonpost/html2ans/">html2ans @ github</a></li>
    
    <li class="toctree-l1"><a href="https://github.com/washingtonpost/html2ans/issues">Issue Tracker</a></li>
    
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>